# 디자인 패턴

## 관련 질문
<details>
  <summary>프론트엔드 개발 과정에서 백앤드 서버와 통신할 때 발생하는 CORS에러와 이를 해결하는 방법에 대해 설명해주세요</summary>
  <blockquote>
    CORS는 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘 입니다. 이로 인해 발생하는 에러는 프록시 서버를 통해 프론트엔드 서버에서 요청되는 오리진과 백엔드 서버의 포트 번호를 일치시키는 방식으로 해결할 수 있습니다.
  </blockquote>
</details>
<br/>
<details>
  <summary>디자인 패턴의 개념에 대해 설명해주세요</summary>
  <blockquote>
    디자인 패턴은 프로그램을 설계할 때 발생했던 문제들을 객체 간 상호관계 등을 이용하여 해결할 수 있도록 하나의 규약 형태로 정리한 것을 의미합니다. 
  </blockquote>
</details>
<br/>
<details>
  <summary>MVC, MVP, MVVM 패턴에 대해 설명해주세요</summary>
  <blockquote>
    MVC 패턴은 모델, 뷰, 컨트롤러로 이루어진 패턴으로 각 요소에만 집중해서 개발할 수 있다는 장점이 있습니다. 사용자가 볼 수 있는 화면인 뷰에서 변경이 발생하면 컨트롤러가 이를 모델로 전달하여 모델이 생성되거나 갱신됩니다<br/>
    MVP는 MVC에서 파생된 패턴으로 컨트롤러가 프레젠터로 교체된 패턴입니다. 뷰와 프레젠터가 일대일 관계로 강하게 결합되어있습니다.<br/>
    MVVM 패턴은 컨트롤러가 뷰 모델로 바뀐 패턴으로 MVC와 달리 커맨드와 데이터 바인딩을 가지는 특징이 있습니다. 
  </blockquote>
</details>
<br/>
<details>
  <summary>디자인 패턴의 분류 기준에 대해 설명해주세요</summary>
  <blockquote>
    디자인 패턴은 그 목적에 따라 생성, 구조, 행위 패턴으로 분류할 수 있습니다. 생성 패턴으로는 싱글톤 패턴이 있으며 구조 패턴으로는 프록시 패턴이, 행위 패턴으로는 옵저버 패턴과 전략 패턴 등이 있습니다.
  </blockquote>
</details>

<br/><br/>

## 디자인 패턴
- 프로그램을 설계할 때 발생했던 문제들을 객체 간의 상호관계 등을 이용하여 해결할 수 있도록 하나의 규약형태로 만들어 놓은 것

### 싱글톤 패턴
- 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴
- 하나의 인스턴스를 다른 모듈들이 공유하므로 인스턴스 생성 비용이 줄어드는 장점
- 의존성이 높다는 단점
- TDD의 걸림돌 : 단위 테스트는 테스트가 서로 독립적이어야 하는데 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이므로 각 테스트마다 독립적인 인스턴스를 만들기 어렵다.

#### 의존성 주입
- 메인 모듈과 하위 모듈 사이에 의존성 주입자를 두어 메인 모듈이 간접적으로 의존성을 주입하는 방식
- 모듈을 쉽게 교체할 수 있는 구조가 되어 테스팅이 쉽고 마이그레이션 수월해진다.

<br/>

### 팩토리 패턴
- 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴으로 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고 하위 클래스에서 객체 생성에 대한 구체적인 내용을 결정하는 패턴
- 유연성, 유지 보수성 증가

<br/>

### 전략 패턴
- 객체의 행위를 바꾸고 싶은 경우 직접 수정하지 않고 전략이라고 부르는 ‘캡슐화한 알고리즘’을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴

- Passport의 전략 패턴
    - Node.js에서 인증 모듈을 구현할 때 쓰는 미들웨어 라이브러리로 여러가지 ‘전략’을 기반으로 인증할 수 있게 한다

<br/>

### 옵저버 패턴
- 주체(관찰자)가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴
- 주로 이벤트 기반 시스템에 사용
- MVC(model -view-controller) 패턴에도 사용된다.
- 자바스크립트에서의 옵저버 패턴
    - 프록시 객체를 통해 구현할 수 있다.
    - 프록시 객체
        - 어떠한 대상의 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수 호출 등)의 작업을 가로챌 수 있는 객체
    - [자바스크립트 프록시](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
- Vue.js 3.0의 옵저버 패턴
    - ref나 reactive로 정의하면 해당 값이 변경될 때 자동으로 DOM에 있는 값이 변경되는 데 이는 프록시 객체를 이용한 옵저버 패턴을 이용하여 구현한 것이다.

<br/>

### 프록시 패턴과 프록시 서버
**프록시 패턴**

- 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 해당 접근을 필터링 하거나 수정하는 등의 역할을 하는 계층이 있는 디자인 패턴
- 이를 통해 객체의 속성, 변환 등을 보완하며 보안, 데이터 검증, 캐싱, 로깅에 사용
- 프록시 객체로 쓰이기도 하며 프록시 서버로도 활용된다.
- 프록시 서버에서의 캐싱
    - 캐시 안에 정보를 담아두고 캐시 안의 정보를 요구하는 요청에 대해 다시 원격 서버에 요청하지 않고 캐시에 있는 데이터를 활용하는 것을 의미한다. 트래픽을 줄일 수 있다는 장점이 있다.

**프록시 서버**

- 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 시스템을 의미
- 프록시 서버로 쓰는 nginx
    - nignx는 비동기 이벤트 기반의 구조와 다수의 연결을 효과적으로 처리 가능한 웹 서버이며 주로 Node.js 서버 앞단의 프록시 서버로 활용된다.
    - Node.js의 버퍼 오버플로우 취약점을 예방하기 위해서 nginx를 프록시 서버로 앞단에 두고 Node.js를 뒤쪽에 둔다.
    - 익명 사용자가 직접적으로 서버에 접근하는 것을 차단하여 보안을 강화할 수 있다.

- 프록시 서버로 쓰는 CloudFlare
    - CloudFlare는 전 세계적으로 분산된 서버가 있고 이를 통해 어떠한 시스템의 콘텐츠 전달을 빠르게 할 수 있는 CDN(Content Delivery Network) 서비스
    - 웹 서버 앞단에 프록시 서버로 두어 디도스 공격 방어나 https 구축에 쓰인다.
    - 디도스는 짧은 기간 동안 다량의 요청을 보내 네트워크를 마비시켜 웹 사이트의 가용성을 방해하는 사이버 공격이다. CloudFlare의 거대한 네트워크 용량과 캐싱 전략으로 소규모 디도스 공격을 쉽게 막고 방화벽 대시보드를 제공한다.

- CORS와 프론트엔드의 프록시 서버
    - Cross-Origin Resource Sharing은 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘이다.
        - 오리진: 프로토콜과 호스트 이름, 포트의 조합
    - 개발 과정에서 백엔드 서버와 통신할 때 CORS 에러를 해결하기 위해 프론트엔드에서 프록시 서버를 만들기도 한다.
        - 프록시 서버를 통해 오리진을 변경하는 방법
    
<br/>

### 이터레이터 패턴
- 이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴
- 순회 가능한 자료형의 구조와 상관없이 이터레이터라는 하나의 인터페이스로 순회 가능

<br/>

### 노출모듈 패턴

- 즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴
- 자바스크립트는 private, public 같은접근 제어자가 없고 전역 범위에서 스크립트가 실행되므로 노출모듈 패턴을 통해 이를 구현하기도 한다.

<br/>

### MVC 패턴

- Model, View, Controller로 이루어진 디자인 패턴
- 모델
    - 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등을 의미
    - 뷰에서 데이터를 생성하거나 수정하면 컨트롤러를 통해 모델을 생성하거나 갱신
- 뷰
    - inputbox, checkbox, textarea 등 사용자 인터페이스 요소
    - 모델을 기반으로 사용자가 볼 수 있는 화면을 의미
    - 변경이 일어나면 컨트롤러에 전달
- 컨트롤러
    - 모델과 뷰를 연결하는 다리
    - 메인 로직을 담당
    - 모델과 뷰의 생명주기를 관리
    - 모델이나 뷰의 변경 통지를 받으면 이를 해석하여 각각의 구성 요소에 해당 내용을 알려준다.

<br/>

### MVP 패턴

- MVC 패턴으로부터 파생, C가 Presenter로 교체된 패턴
- 뷰와 프레젠터는 일대일 관계로 MVC 패턴보다 강한 결합을 가진 패턴이다.

<br/>

### MVVM 패턴

- MVC의 C가 view model로 바뀐 패턴
- 뷰 모델은 뷰를 더 추상화한 계층으로 MVC와 다르게 커맨드와 데이터 바인딩을 갖는다.
    - 커맨드: 여러 가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법
    - 데이터 바인딩: 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법, 뷰 모델 변경 시 뷰가 변경된다.
- 뷰와 뷰 모델 사이의 양방향 데이터 바인딩을 지원하며 ui를 별도의 코드 수정없이 재사용할 수 있고 단위 테스팅이 용이하다.
- Vue.js가 대표적인 프레임워크
    - 함수 사용하지 않고도 값을 대입하여 변수를 변경할 수 있고, 양방향 바인딩, html을 토대로 컴포넌트를 구축할 수 있다는 점이 특징

[프론트엔드 패턴](https://www.youtube.com/watch?v=Y5vOfv67h8A)

<br/>
